---
layout: default
---

<div class="grid grid-cols-1 lg:grid-cols-12 gap-10">
  <!-- Main content -->
  <main class="lg:col-span-8">
    <div class="max-w-4xl">
      <div class="flex flex-col gap-3">
        <div>
          <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">{{ page.title }}</h1>

          {% if page.description %}
            <p class="mt-2 text-slate-600 leading-relaxed dark:text-slate-300">{{ page.description }}</p>
          {% endif %}

          <div class="mt-3 flex flex-wrap items-center gap-2 text-sm">
            {% if page.category %}
              <span class="inline-flex items-center rounded-full bg-emerald-600/10 px-2 py-0.5 text-xs text-emerald-800 ring-1 ring-emerald-700/20 dark:text-emerald-200">
                {{ page.category }}
              </span>
            {% endif %}

            {% if page.github %}
              <a class="text-emerald-700 hover:underline dark:text-emerald-300" href="{{ page.github }}" target="_blank" rel="noreferrer">
                View on GitHub
              </a>
            {% endif %}
          </div>
        </div>
      </div>

      <div class="mt-8 rounded-2xl bg-white/80 ring-1 ring-slate-200 p-6 shadow-card dark:bg-slate-900/40 dark:ring-slate-800">
        <div id="readmeStatus" class="text-sm text-slate-600 dark:text-slate-300"></div>
        <div id="readme" class="prose prose-slate max-w-none mt-4 dark:prose-invert"></div>

        <div id="readmeFallback" class="hidden mt-4 text-sm text-slate-600 dark:text-slate-300">
          We couldn’t load the README right now. You can still open it directly on GitHub:
          <a class="text-emerald-700 hover:underline dark:text-emerald-300" href="{{ page.github }}" target="_blank" rel="noreferrer">{{ page.github }}</a>
        </div>
      </div>

      <div class="mt-8 text-sm text-slate-600 dark:text-slate-300">
        <a class="hover:underline" href="{{ '/' | relative_url }}">← Back to all lists</a>
      </div>
    </div>
  </main>

  <!-- Sidebar -->
  <aside class="lg:col-span-4">
    <div class="lg:sticky lg:top-8">
      {% include list_sidebar.html %}
    </div>
  </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

<script>
(function() {
  const slug = {{ page.slug | jsonify }};
  const github = {{ page.github | jsonify }};
  const cacheKey = `awesomelists_readme_${slug}`;
  const ttlMs = 24 * 60 * 60 * 1000; // 24h

  const $status = document.getElementById('readmeStatus');
  const $readme = document.getElementById('readme');
  const $fallback = document.getElementById('readmeFallback');

  // Sidebar hooks (optional but recommended)
  const $sideStatus = document.getElementById('listFetchStatus');
  const $sideFetchedAt = document.getElementById('listFetchedAt');
  const $sideCacheHint = document.getElementById('listCacheHint');

  const $refresh = document.getElementById('btnRefresh');
  const $copy = document.getElementById('btnCopyLink');
  const $share = document.getElementById('btnShare');

  function setStatus(html) { if ($status) $status.innerHTML = html; }
  function showFallback(show) { if ($fallback) $fallback.classList.toggle('hidden', !show); }

  function setSideStatus(text) { if ($sideStatus) $sideStatus.textContent = text; }
  function setSideFetchedAt(text) { if ($sideFetchedAt) $sideFetchedAt.textContent = text; }
  function showSideCacheHint(show) { if ($sideCacheHint) $sideCacheHint.classList.toggle('hidden', !show); }

  function parseRepo(url) {
    const m = String(url).match(/^https?:\/\/github\.com\/([^\/]+)\/([^\/]+)(?:\/|$)/i);
    if (!m) return null;
    return { owner: m[1], repo: m[2].replace(/\.git$/i, '') };
  }

  function formatDate(ts) {
    try {
      return new Date(ts).toLocaleString(undefined, {
        year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'
      });
    } catch { return ''; }
  }

  function readCache() {
    try {
      const raw = localStorage.getItem(cacheKey);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || !obj.md) return null;
      return obj;
    } catch { return null; }
  }

  function writeCache(md) {
    try {
      localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), md }));
    } catch {}
  }

  function renderMarkdown(md) {
    const html = marked.parse(md, { mangle: false, headerIds: true });
    $readme.innerHTML = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
  }

  async function fetchReadme(opts) {
    const force = !!(opts && opts.force);
    showFallback(false);
    showSideCacheHint(false);

    const cached = readCache();
    const fresh = cached && (Date.now() - cached.ts) < ttlMs;

    if (!force && fresh) {
      const t = formatDate(cached.ts);
      setStatus(`Showing cached version from <strong>${t}</strong>.`);
      setSideStatus('Cached');
      setSideFetchedAt(t);
      renderMarkdown(cached.md);
      return;
    }

    if (cached && !fresh) {
      setStatus(`Refreshing… (last cached <strong>${formatDate(cached.ts)}</strong>)`);
      setSideStatus('Refreshing…');
      setSideFetchedAt(formatDate(cached.ts));
    } else {
      setStatus('Loading README…');
      setSideStatus('Loading…');
    }

    const repo = parseRepo(github);
    if (!repo) {
      setStatus('Could not parse GitHub repository URL.');
      setSideStatus('Error');
      showFallback(true);
      return;
    }

    const candidates = [
      `https://raw.githubusercontent.com/${repo.owner}/${repo.repo}/main/README.md`,
      `https://raw.githubusercontent.com/${repo.owner}/${repo.repo}/main/readme.md`,
      `https://raw.githubusercontent.com/${repo.owner}/${repo.repo}/master/README.md`,
      `https://raw.githubusercontent.com/${repo.owner}/${repo.repo}/master/readme.md`
    ];

    let lastErr = null;

    for (const url of candidates) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) { lastErr = new Error(`${res.status} ${res.statusText}`); continue; }
        const md = await res.text();
        if (!md || md.trim().length === 0) { lastErr = new Error('Empty README'); continue; }

        writeCache(md);
        const now = Date.now();
        setStatus(`Loaded live from GitHub. Cached <strong>${formatDate(now)}</strong>.`);
        setSideStatus('Live');
        setSideFetchedAt(formatDate(now));
        renderMarkdown(md);
        return;
      } catch (e) {
        lastErr = e;
      }
    }

    if (cached && cached.md) {
      setStatus(`Couldn’t load live README (rate-limited or unavailable). Showing cached version from <strong>${formatDate(cached.ts)}</strong>.`);
      setSideStatus('Cached (fallback)');
      setSideFetchedAt(formatDate(cached.ts));
      showSideCacheHint(true);
      renderMarkdown(cached.md);
      return;
    }

    setStatus(`Couldn’t load README right now. (${(lastErr && lastErr.message) ? lastErr.message : 'Unknown error'})`);
    setSideStatus('Error');
    showFallback(true);
  }

  // Sidebar buttons
  if ($copy) {
    $copy.addEventListener('click', async () => {
      const url = new URL(`/lists/${slug}/`, window.location.origin).href;
      try {
        await navigator.clipboard.writeText(url);
        setStatus('Link copied to clipboard.');
      } catch {
        setStatus('Could not copy link (browser blocked clipboard).');
      }
    });
  }

  if ($share) {
    $share.addEventListener('click', async () => {
      const url = new URL(`/lists/${slug}/`, window.location.origin).href;
      const title = document.title || {{ page.title | jsonify }};
      try {
        if (navigator.share) {
          await navigator.share({ title, url });
          setStatus('Share dialog opened.');
        } else {
          await navigator.clipboard.writeText(url);
          setStatus('Share not supported here. Link copied instead.');
        }
      } catch {
        setStatus('Could not share right now.');
      }
    });
  }

  if ($refresh) $refresh.addEventListener('click', () => fetchReadme({ force: true }));

  fetchReadme();
})();
</script>
